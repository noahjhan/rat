#ifndef DICTIONARY_HPP
#define DICTIONARY_HPP

#include <string>
#include <unordered_map>

#include "token.hpp"

const std::unordered_map<std::string, ConstituentToken> DICT_INIT = {
{"int", ConstituentToken::TYPE_INT},
{"float", ConstituentToken::TYPE_FLOAT},
{"double", ConstituentToken::TYPE_DOUBLE},
{"bool", ConstituentToken::TYPE_BOOL},
{"char", ConstituentToken::TYPE_CHAR},
{"long", ConstituentToken::TYPE_LONG},
{"short", ConstituentToken::TYPE_SHORT},
{"pointer", ConstituentToken::TYPE_POINTER},
{"uint", ConstituentToken::TYPE_UINT},
{"ulong", ConstituentToken::TYPE_ULONG},
{"ushort", ConstituentToken::TYPE_USHORT},
{"uchar", ConstituentToken::TYPE_UCHAR},
{"string", ConstituentToken::TYPE_STRING},
{"op_int", ConstituentToken::TYPE_OP_INT},
{"op_float", ConstituentToken::TYPE_OP_FLOAT},
{"op_double", ConstituentToken::TYPE_OP_DOUBLE},
{"op_bool", ConstituentToken::TYPE_OP_BOOL},
{"op_char", ConstituentToken::TYPE_OP_CHAR},
{"op_long", ConstituentToken::TYPE_OP_LONG},
{"op_short", ConstituentToken::TYPE_OP_SHORT},
{"op_uint", ConstituentToken::TYPE_OP_UINT},
{"op_ulong", ConstituentToken::TYPE_OP_ULONG},
{"op_ushort", ConstituentToken::TYPE_OP_USHORT},
{"op_uchar", ConstituentToken::TYPE_OP_UCHAR},
{"op_string", ConstituentToken::TYPE_OP_STRING},
{"let", ConstituentToken::VARIABLE_DECLARATION_LET},
{"oplet", ConstituentToken::VARIABLE_DECLARATION_OPLET},
{"fn", ConstituentToken::FUNCTION_DECLARATION_F},
{"fn_", ConstituentToken::FUNCTION_DECLARATION_F_VOID},
{"fn?", ConstituentToken::FUNCTION_DECLARATION_F_OPTIONAL},
{"fn/", ConstituentToken::FUNCTION_DECLARATION_F_LAMBDA},
{"ret", ConstituentToken::FUNCTION_RETURN},
{"rev", ConstituentToken::FUNCTION_DECLARATION_F_VOID},
{"if", ConstituentToken::CONDITIONAL_IF},
{"else", ConstituentToken::CONDITIONAL_ELSE},
{"elif", ConstituentToken::CONDITIONAL_ELSE_IF},
{"match", ConstituentToken::PATTERN_MATCH},
{"null", ConstituentToken::NULL_LITERAL},
{":", ConstituentToken::COLON},
{"'", ConstituentToken::SINGLE_QUOTE},
{"\"", ConstituentToken::DOUBLE_QUOTE},
{",", ConstituentToken::COMMA},
{"[", ConstituentToken::BRACKET_OPEN},
{"]", ConstituentToken::BRACKET_CLOSE},
{"{", ConstituentToken::BRACE_OPEN},
{"}", ConstituentToken::BRACE_CLOSE},
{"(", ConstituentToken::PARENTHESES_OPEN},
{")", ConstituentToken::PARENTHESES_CLOSE},
{"//", ConstituentToken::COMMENT_LINE},
{"/*", ConstituentToken::COMMENT_BLOCK_OPEN},
{"*/", ConstituentToken::COMMENT_BLOCK_CLOSE},
{"=", ConstituentToken::ASSIGNMENT},
{"+", ConstituentToken::ARITHMETHIC_ADD},
{"-", ConstituentToken::ARITHMETHIC_MUL},
{"*", ConstituentToken::ARITHMETHIC_MUL},
{"/", ConstituentToken::ARITHMETHIC_DIV},
{"%", ConstituentToken::ARITHMETHIC_MOD},
{"==", ConstituentToken::COMPARISON_EQ},
{"!=", ConstituentToken::COMPARISON_NEQ},
{"<", ConstituentToken::COMPARISON_LT},
{">", ConstituentToken::COMPARISON_GT},
{"<=", ConstituentToken::COMPARISON_LTE},
{">=", ConstituentToken::COMPARISON_GTE},
{"&&", ConstituentToken::LOGICAL_AND},
{"||", ConstituentToken::LOGICAL_OR},
{"!", ConstituentToken::LOGICAL_NOT},
{"&", ConstituentToken::BITWISE_AND},
{"|", ConstituentToken::BITWISE_OR},
{"^", ConstituentToken::BITWISE_XOR},
{"~", ConstituentToken::BITWISE_NEG},
{"<<", ConstituentToken::BITWISE_SL},
{">>", ConstituentToken::BITWISE_SR},
{"->", ConstituentToken::ARROW}};

#endif // DICTIONARY_HPP