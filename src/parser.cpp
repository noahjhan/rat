#include "parser.hpp"

/**
 * @brief
 * constructor for parser should validate tokens generated by lexer.
 * Although, lexer should handle most of the errors associated with unrecognized
 * tokens. Realistically, parse errors should occur elsewhere when the provided
 * deque does not match language grammar.
 *
 * skip literals becuase they are
 * validated in lexer in advanceLiteral()
 *
 * skip identifiers because they are
 * validated in lexer in advanceToken()
 *
 * tl;dr
 * this constructor may be redundant / for debug purposes
 *
 * @todo copy over the debug functions from lexer, maybe make a generic
 * debug.cpp file
 *
 * @todo identifiers in expression infinite loo
 *
 * @todo update grammar for new ops
 */

// this code is for debugging purposes...
// ideally this function calls dispatch which predicts the
// syntax tree to generate
Parser::Parser(std::deque<Token> &tokens, RatSource &source_file)
: tokens_(tokens), source_file_(source_file)
{

  for (const auto &token : tokens_)
  {
    if (token.value.empty())
    {
      throw std::invalid_argument("syntax error: empty token");
    }
    switch (token.type)
    {
      case GenericToken::IDENTIFIER: break;
      case GenericToken::KEYWORD:
        if (dictionary_.find(token.value) == dictionary_.end())
        {
          std::cerr << "recieved: '" << token.value << '\'' << std::endl;
          throw std::invalid_argument("syntax error: unrecognized keyword");
        }
        break;
      case GenericToken::NUMERIC_LITERAL: break;
      case GenericToken::STRING_LITERAL: break;
      case GenericToken::CHAR_LITERAL: break;
      case GenericToken::PUNCTUATOR:
        if (dictionary_.find(token.value) == dictionary_.end())
        {
          std::cerr << "recieved: '" << token.value << '\'' << std::endl;
          throw std::invalid_argument("syntax error: unrecognized punctuator");
        }
        break;
      case GenericToken::OPERATOR:
        if (dictionary_.find(token.value) == dictionary_.end())
        {
          std::cerr << "recieved: '" << token.value << '\'' << std::endl;
          throw std::invalid_argument("syntax error: unrecognized operator");
        }
        break;
      case GenericToken::TYPE:
        if (dictionary_.find(token.value) == dictionary_.end())
        {
          std::cerr << "recieved: '" << token.value << '\'' << std::endl;
          throw std::invalid_argument("syntax error: unrecognized type");
        }
        break;
    }
  }
}
/// @todo
///
/// the point of this dispatch will be to pop a token
/// peek the next token and use only that information
/// to determine how to interpret them into AST
void Parser::dispatch()
{
  // expext expressions to occur
  // 1 - Variable Assignment
  // 2 - As Function Param
  // 3 - Conditional Expr
  // 4 - Return Values
}

// let x: int = 10
std::unique_ptr<Node::VariableDecl> Parser::variableDeclaration()
{

  if (tokens_.front().type != GenericToken::KEYWORD)
    throw std::invalid_argument(
    "error: expected keyword in variable declaration");

  tokens_.pop_front();
  if (tokens_.empty()) throw std::invalid_argument("out of tokens");

  if (tokens_.front().type != GenericToken::IDENTIFIER)
    throw std::invalid_argument(
    "error: expected identifier in variable delcaration");

  Node::VariableDecl variable_decl;
  variable_decl.token = tokens_.front();
  tokens_.pop_front();

  if (tokens_.empty()) throw std::invalid_argument("out of tokens");
  if (tokens_.front().type != GenericToken::PUNCTUATOR)
    throw std::invalid_argument(
    "error: expected punctuator in variable declaration");

  tokens_.pop_front();

  if (tokens_.empty()) throw std::invalid_argument("out of tokens");
  if (tokens_.front().type != GenericToken::TYPE)
    throw std::invalid_argument("error: expected type in variable declaration");
  if (dictionary_.find(tokens_.front().value) == dictionary_.end())
    throw std::invalid_argument(
    "error: unrecognized type in variable declatation");

  variable_decl.type = dictionary_.at(tokens_.front().value);
  tokens_.pop_front();

  if (tokens_.empty()) throw std::invalid_argument("out of tokens");
  if (tokens_.front().type != GenericToken::OPERATOR)
    throw std::invalid_argument(
    "error: expected assignment operator in expression");

  tokens_.pop_front();
  if (tokens_.empty()) throw std::invalid_argument("out of tokens");

  variable_decl.expr = recurseExpr();

  return std::make_unique<Node::VariableDecl>(std::move(variable_decl));
}

std::unique_ptr<Node::GenericExpr> Parser::recurseNumeric()
{
  if (!tokens_.empty() &&
      (tokens_.front().type == GenericToken::NUMERIC_LITERAL ||
       tokens_.front().type == GenericToken::IDENTIFIER))
  {
    return tokenToExpr();
  }
  return nullptr;
}

std::unique_ptr<Node::GenericExpr> Parser::recurseFactor()
{
  if (tokens_.empty()) return nullptr;
  if (tokens_.front().value == "!" || tokens_.front().value == "~")
  {
    tokens_.pop_front();
    Node::UnaryExpr un_expr;
    un_expr.op = (tokens_.front().value == "!") ?
                 ConstituentToken::BITWISE_NEG :
                 ConstituentToken::LOGICAL_NOT;
    un_expr.expr = recurseFactor();
    auto factor = std::make_unique<Node::GenericExpr>(Node::GenericExpr{
    std::make_unique<EXPRESSION_VARIANT>(std::move(un_expr))});
    return factor;
  }

  if (tokens_.front().type == GenericToken::NUMERIC_LITERAL ||
      tokens_.front().type == GenericToken::IDENTIFIER)
  {
    return recurseNumeric();
  }

  if (tokens_.front().value == "(")
  {
    tokens_.pop_front(); // Consume '('
    auto expr = recurseExpr();
    if (tokens_.empty())
    {
      throw std::invalid_argument(
      "syntax error: invalid parentheses expression");
    }
    tokens_.pop_front(); // Consume ')'
    return expr;
  }
  return nullptr;
}

std::unique_ptr<Node::GenericExpr> Parser::recurseTerm()
{
  auto factor = recurseFactor();
  while (!tokens_.empty() &&
         (tokens_.front().value == "*" || tokens_.front().value == "/" ||
          tokens_.front().value == "%"))
  {
    if (!factor)
    {
      throw std::invalid_argument("error: expecting lhs for binary expression");
    }
    Node::BinaryExpr bin_expr;
    bin_expr.lhs = std::move(factor);

    if (tokens_.front().value == "*")
      bin_expr.op = ConstituentToken::ARITHMETIC_MUL;
    else if (tokens_.front().value == "/")
      bin_expr.op = ConstituentToken::ARITHMETIC_DIV;
    else if (tokens_.front().value == "%")
      bin_expr.op = ConstituentToken::ARITHMETIC_MOD;

    tokens_.pop_front();
    auto factor_rhs = recurseFactor();
    if (!factor_rhs)
    {
      throw std::invalid_argument("error: expecting rhs for binary expression");
    }
    bin_expr.rhs = std::move(factor_rhs);
    factor = std::make_unique<Node::GenericExpr>(Node::GenericExpr{
    std::make_unique<EXPRESSION_VARIANT>(std::move(bin_expr))});
  }
  return factor;
}

std::unique_ptr<Node::GenericExpr> Parser::recurseAdditive()
{
  auto term = recurseTerm();
  while (!tokens_.empty() &&
         (tokens_.front().value == "+" || tokens_.front().value == "-"))
  {
    if (!term)
    {
      throw std::invalid_argument("error: expecting lhs for binary expression");
    }
    Node::BinaryExpr bin_expr;
    bin_expr.lhs = std::move(term);
    bin_expr.op = (tokens_.front().value == "+") ?
                  ConstituentToken::ARITHMETIC_ADD :
                  ConstituentToken::ARITHMETIC_SUB;
    tokens_.pop_front();
    auto term_rhs = recurseTerm();
    if (!term_rhs)
    {
      throw std::invalid_argument("error: expecting rhs for binary expression");
    }
    bin_expr.rhs = std::move(term_rhs);
    term = std::make_unique<Node::GenericExpr>(Node::GenericExpr{
    std::make_unique<EXPRESSION_VARIANT>(std::move(bin_expr))});
  }
  return term;
}

std::unique_ptr<Node::GenericExpr> Parser::recurseShift()
{
  auto additive = recurseAdditive();
  while (!tokens_.empty() &&
         (tokens_.front().value == "<<" || tokens_.front().value == ">>"))
  {
    if (!additive)
    {
      throw std::invalid_argument("error: expecting lhs for binary expression");
    }
    Node::BinaryExpr bin_expr;
    bin_expr.lhs = std::move(additive);

    if (tokens_.front().value == "<<")
      bin_expr.op = ConstituentToken::BITWISE_SL;
    else if (tokens_.front().value == ">>")
      bin_expr.op = ConstituentToken::BITWISE_SR;

    tokens_.pop_front();
    auto additive_rhs = recurseAdditive();
    if (!additive_rhs)
    {
      throw std::invalid_argument("error: expecting rhs for binary expression");
    }
    bin_expr.rhs = std::move(additive_rhs);
    additive = std::make_unique<Node::GenericExpr>(Node::GenericExpr{
    std::make_unique<EXPRESSION_VARIANT>(std::move(bin_expr))});
  }
  return additive;
}

std::unique_ptr<Node::GenericExpr> Parser::recurseComparison()
{
  auto shift = recurseShift();
  while (!tokens_.empty() &&
         (tokens_.front().value == "==" || tokens_.front().value == "!=" ||
          tokens_.front().value == "<" || tokens_.front().value == "<=" ||
          tokens_.front().value == ">" || tokens_.front().value == ">="))
  {
    if (!shift)
    {
      throw std::invalid_argument("error: expecting lhs for binary expression");
    }

    Node::BinaryExpr bin_expr;
    bin_expr.lhs = std::move(shift);

    if (tokens_.front().value == "==")
      bin_expr.op = ConstituentToken::COMPARISON_EQ;
    else if (tokens_.front().value == "!=")
      bin_expr.op = ConstituentToken::COMPARISON_NEQ;
    else if (tokens_.front().value == "<")
      bin_expr.op = ConstituentToken::COMPARISON_LT;
    else if (tokens_.front().value == "<=")
      bin_expr.op = ConstituentToken::COMPARISON_LTE;
    else if (tokens_.front().value == ">")
      bin_expr.op = ConstituentToken::COMPARISON_GT;
    else if (tokens_.front().value == ">=")
      bin_expr.op = ConstituentToken::COMPARISON_GTE;

    tokens_.pop_front();
    auto shift_rhs = recurseShift();
    if (!shift_rhs)
    {
      throw std::invalid_argument("error: expecting rhs for binary expression");
    }
    bin_expr.rhs = std::move(shift_rhs);
    shift = std::make_unique<Node::GenericExpr>(Node::GenericExpr{
    std::make_unique<EXPRESSION_VARIANT>(std::move(bin_expr))});
  }
  return shift;
}

std::unique_ptr<Node::GenericExpr> Parser::recurseLogical()
{
  auto comparison = recurseComparison();
  while (!tokens_.empty() &&
         (tokens_.front().value == "&" || tokens_.front().value == "^" ||
          tokens_.front().value == "|" || tokens_.front().value == "&&" ||
          tokens_.front().value == "||"))
  {
    if (!comparison)
    {
      throw std::invalid_argument("error: expecting lhs for binary expression");
    }
    Node::BinaryExpr bin_expr;
    bin_expr.lhs = std::move(comparison);

    if (tokens_.front().value == "&")
      bin_expr.op = ConstituentToken::BITWISE_AND;
    else if (tokens_.front().value == "^")
      bin_expr.op = ConstituentToken::BITWISE_XOR;
    else if (tokens_.front().value == "|")
      bin_expr.op = ConstituentToken::BITWISE_OR;
    else if (tokens_.front().value == "&&")
      bin_expr.op = ConstituentToken::LOGICAL_AND;
    else if (tokens_.front().value == "||")
      bin_expr.op = ConstituentToken::LOGICAL_OR;

    tokens_.pop_front();

    auto comparison_rhs = recurseComparison();
    if (!comparison_rhs)
    {
      throw std::invalid_argument("error: expecting rhs for binary expression");
    }
    bin_expr.rhs = std::move(comparison_rhs);
    comparison = std::make_unique<Node::GenericExpr>(Node::GenericExpr{
    std::make_unique<EXPRESSION_VARIANT>(std::move(bin_expr))});
  }
  return comparison;
}

std::unique_ptr<Node::GenericExpr> Parser::recurseExpr()
{
  auto logical = recurseLogical();
  if (!logical)
  {
    if (tokens_.empty())
    {
      throw std::runtime_error("token deque empty");
    }
    Token token = tokens_.front();
    std::cerr << "received: '" << token.value << '\'' << std::endl;
    debugLineCol(token.line_num, token.col_num);
    debugPrintln(token.line_num);
    throw std::invalid_argument("error: invalid syntax");
  }
  if (std::holds_alternative<Node::BinaryExpr>(*(logical->expr)))
  {
    if (!std::get<Node::BinaryExpr>(*(logical->expr)).lhs)
    {
      throw std::invalid_argument("error: expecting lhs for binary expression");
    }
    if (!std::get<Node::BinaryExpr>(*(logical->expr)).rhs)
    {
      throw std::invalid_argument("error: expecting rhs for binary expression");
    }
  }
  return logical;
}

std::unique_ptr<Node::GenericExpr> Parser::tokenToExpr()
{
  // lets assume for now the deque only contains valid expression tokens
  // lets assume for now the deque only contains puctuators, literals,
  // operators I guess currently this takes in a deque and pops a token, and
  // processes it as if it is part of an expression
  //
  //
  Token token = tokens_.front();
  if (tokens_.empty())
  {
    throw std::runtime_error("error: empty token deque");
  }

  std::unique_ptr<Node::GenericExpr> gen_expr_ptr;
  tokens_.pop_front(); // maybe here maybe at the end

  switch (token.type)
  {
    /// @todo seperate functions maybe seperated struct for function and
    /// variable identifiers
    case GenericToken::IDENTIFIER:
    {
      Node::Identifier node;
      node.token = token;
      node.type = ConstituentToken::VARIABLE_ID; // not exactly true -> does
                                                 // not support functions
      auto ptr = std::make_unique<EXPRESSION_VARIANT>(node);
      Node::GenericExpr gen_expr;
      gen_expr.expr = std::move(ptr);
      gen_expr_ptr = std::make_unique<Node::GenericExpr>(std::move(gen_expr));
    }
    break;
    case GenericToken::KEYWORD:
      throw std::invalid_argument("error: keyword found in expression");
    case GenericToken::NUMERIC_LITERAL:
    {
      Node::NumericLiteral node;
      node.token = token;
      node.type = inferTypeNumericLiteral(token.value);
      auto ptr = std::make_unique<EXPRESSION_VARIANT>(node);
      Node::GenericExpr gen_expr;
      gen_expr.expr = std::move(ptr);
      gen_expr_ptr = std::make_unique<Node::GenericExpr>(std::move(gen_expr));
    }
    break;
    case GenericToken::STRING_LITERAL:
      std::cerr << "recieved: '" << token.value << '\'' << std::endl;
      throw std::runtime_error("string literal : @todo");
    case GenericToken::CHAR_LITERAL:
    {
      Node::NumericLiteral node;
      node.token = token;
      node.type = ConstituentToken::TYPE_CHAR;
      auto ptr = std::make_unique<EXPRESSION_VARIANT>(node);
      Node::GenericExpr gen_expr;
      gen_expr.expr = std::move(ptr);
      gen_expr_ptr = std::make_unique<Node::GenericExpr>(std::move(gen_expr));
    }
    break;
    case GenericToken::PUNCTUATOR: break;
    case GenericToken::OPERATOR: break;
    case GenericToken::TYPE:
      throw std::invalid_argument("error: keyword found in expression");
  }
  if (gen_expr_ptr)
  {
    return gen_expr_ptr;
  }
  std::cerr << "received: '" << token.value << '\'' << std::endl;
  throw std::invalid_argument("error: unrecognized token in expression");
}

/// @todo suppport for optional
/// @todo move some of this to lexer
/// @todo create usuable regex
ConstituentToken Parser::inferTypeNumericLiteral(const std::string &value)
{
  bool is_u_type = value.find('u') != std::string::npos;
  bool is_f_type = value.find('f') != std::string::npos ||
                   value.find('d') != std::string::npos ||
                   value.find('.') != std::string::npos;

  // this is already checked in lexer.cpp
  if (is_u_type && is_f_type)
  {
    throw std::invalid_argument("ambiguous numeric literal");
  }

  // type inference default int
  if (std ::isdigit(value.back()))
  {
    return is_f_type ? ConstituentToken::TYPE_DOUBLE :
                       ConstituentToken::TYPE_INT;
  }

  switch (value.back())
  {
    case 'u': return ConstituentToken::TYPE_UINT;
    case 'i':
      return is_u_type ? ConstituentToken::TYPE_UINT :
                         ConstituentToken::TYPE_INT;
    case 'l':
      return is_u_type ? ConstituentToken::TYPE_ULONG :
                         ConstituentToken::TYPE_LONG;
    case 's':
      return is_u_type ? ConstituentToken::TYPE_USHORT :
                         ConstituentToken::TYPE_SHORT;
    case 'c':
      return is_u_type ? ConstituentToken::TYPE_UCHAR :
                         ConstituentToken::TYPE_CHAR;
    case 'f': return ConstituentToken::TYPE_FLOAT;
    case 'd': return ConstituentToken::TYPE_DOUBLE;
    case '\0':
      return is_u_type ? ConstituentToken::TYPE_UINT :
                         ConstituentToken::TYPE_INT;
    default:
      std::cerr << value << std::endl;
      throw std::invalid_argument("ambiguous numeric literal token");
  }
}

int Parser::numTokens() const { return tokens_.size(); }

void Parser::debugASTPrinter(Node::GenericExpr &node)
{
  debugASTPrinterRecursive(node, 0);
}

void Parser::debugASTPrinterRecursive(const Node::GenericExpr &node, int depth)
{
  // auto variant =
  // std::make_unique<EXPRESSION_VARIANT>(std::move(*(node.expr)));

  auto variant = node.expr.get();
  if (!variant)
  {
    std::cout << std::string(depth, ' ') << "variant is null" << std::endl;
    return;
  }

  if (std::holds_alternative<Node::GenericExpr>(*variant))
  {
    std::cout << std::string(depth, ' ') << "recursively holds expression"
              << std::endl;
    debugASTPrinterRecursive(std::get<Node::GenericExpr>(*variant), depth + 1);
  }
  else if (std::holds_alternative<Node::BinaryExpr>(*variant))
  {
    auto op = reverse_dictionary_.at(
    std::get<Node::BinaryExpr>(*variant).op); // validate that op is real
    std::cout << "holds binary expression: " << op << std::endl;
    const auto &binaryExpr = std::get<Node::BinaryExpr>(*variant);
    if (binaryExpr.lhs)
    {
      std::cout << std::string(depth * 4, ' ') << "lhs: ";
      debugASTPrinterRecursive(*binaryExpr.lhs, depth + 1);
    }
    else
    {
      throw std::invalid_argument("error: expecting lhs for binary expression");
    }
    if (binaryExpr.rhs)
    {
      std::cout << std::string(depth * 4, ' ') << "rhs: ";
      debugASTPrinterRecursive(*binaryExpr.rhs, depth + 1);
    }
    else
    {
      throw std::invalid_argument("error: expecting rhs for binary expression");
    }
  }
  else if (std::holds_alternative<Node::UnaryExpr>(*variant))
  {
    auto op = reverse_dictionary_.at(std::get<Node::UnaryExpr>(*variant).op);
    std::cout << "holds unary expression: " << op << std::endl;
    const auto &unaryExpr = std::get<Node::UnaryExpr>(*variant);
    if (unaryExpr.expr)
    {
      std::cout << std::string(depth * 4, ' ') << "expr: ";
      debugASTPrinterRecursive(*unaryExpr.expr, depth + 1);
    }
  }
  else if (std::holds_alternative<Node::NumericLiteral>(*variant))
  {
    auto literal = std::get<Node::NumericLiteral>(*variant);
    std::cout << "holds numeric literal: " << literal.token.value << std::endl;
  }
  else if (std::holds_alternative<Node::Identifier>(*variant))
  {
    auto id = std::get<Node::Identifier>(*variant);
    std::cout << "holds identifier: " << id.token.value << std::endl;
  }
  else
  {
    std::cout << "holds ambiguous state" << std::endl;
  }
}

void Parser::debugPrintln(const unsigned int &line_num)
{
  source_file_.seekLine(line_num);
  std::cerr << line_num << " | " << source_file_.readLine() << std::endl;
}

void Parser::debugLineCol(const unsigned int &line_num,
                          const unsigned int &col_num)
{
  std::cerr << "at line: " << line_num << ", col: " << col_num << std::endl;
}