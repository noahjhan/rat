#include "parser.hpp"

/**
 * @brief
 * constructor for parser should validate tokens generated by lexer.
 * Although, lexer should handle most of the errors associated with unrecognized
 * tokens. Realistically, parse errors should occur elsewhere when the provided
 * deque does not match language grammar.
 *
 * skip literals becuase they are
 * validated in lexer in advanceLiteral()
 *
 * skip identifiers because they are
 * validated in lexer in advanceToken()
 *
 * tl;dr
 * this constructor may be redundant / for debug purposes
 *
 * @todo copy over the debug functions from lexer, maybe make a generic
 * debug.cpp file
 *
 * handle unary operators and complex binary operators
 *
 * @todo handle operator precedence and syntax errors such as 2 2 should throw (
 * no operator )
 *
 */

int add(int a, int b) { return a + b; }
// this code is for debugging purposes...
// ideally this function calls dispatch which predicts the
// syntax tree to generate

Parser::Parser(std::deque<Token> &tokens) : tokens_(tokens)
{

  for (const auto &token : tokens_)
  {
    if (token.value.empty())
    {
      throw std::invalid_argument("syntax error: empty token");
    }
    switch (token.type)
    {
      case GenericToken::IDENTIFIER: break;
      case GenericToken::KEYWORD:
        if (dictionary_.find(token.value) == dictionary_.end())
        {
          std::cerr << "recieved: '" << token.value << '\'' << std::endl;
          throw std::invalid_argument("syntax error: unrecognized keyword");
        }
        break;
      case GenericToken::NUMERIC_LITERAL: break;
      case GenericToken::STRING_LITERAL: break;
      case GenericToken::CHAR_LITERAL: break;
      case GenericToken::PUNCTUATOR:
        if (dictionary_.find(token.value) == dictionary_.end())
        {
          std::cerr << "recieved: '" << token.value << '\'' << std::endl;
          throw std::invalid_argument("syntax error: unrecognized punctuator");
        }
        break;
      case GenericToken::OPERATOR:
        if (dictionary_.find(token.value) == dictionary_.end())
        {
          std::cerr << "recieved: '" << token.value << '\'' << std::endl;
          throw std::invalid_argument("syntax error: unrecognized operator");
        }
        break;
      case GenericToken::TYPE:
        if (dictionary_.find(token.value) == dictionary_.end())
        {
          std::cerr << "recieved: '" << token.value << '\'' << std::endl;
          throw std::invalid_argument("syntax error: unrecognized type");
        }
        break;
    }
  }
}
/// @todo
///
/// the point of this dispatch will be to pop a token
/// peek the next token and use only that information
/// to determine how to interpret them into AST
void Parser::dispatch()
{
  if (tokens_.empty())
  {
    throw std::invalid_argument("empty deque");
  }
  Token curr = tokens_.front();
  tokens_.pop_front();
  Token next = tokens_.front();
  switch (curr.type)
  {

    {
      if (dictionary_.find(curr.value) == dictionary_.end())
      {
        std::cerr << "recieved '" << curr.value << '\'' << std::endl;
        throw std::invalid_argument("unrecognized keyword");
      }
      ConstituentToken keyword = dictionary_.at(curr.value);
    }
  }
}
std::unique_ptr<Node::GenericExpr> Parser::recurseNumeric()
{
  if (!tokens_.empty() && tokens_.front().type == GenericToken::NUMERIC_LITERAL)
  {
    return tokenToExpr();
  }
  return nullptr; // Cannot handle identifiers as of yet
}

std::unique_ptr<Node::GenericExpr> Parser::recurseFactor()
{
  if (tokens_.empty()) return nullptr;

  if (tokens_.front().type == GenericToken::NUMERIC_LITERAL ||
      tokens_.front().type == GenericToken::IDENTIFIER)
  {
    return recurseNumeric();
  }

  if (tokens_.front().value == "(")
  {
    tokens_.pop_front(); // Consume '('
    auto expr = recurseExpr();
    if (tokens_.empty() || tokens_.front().value != ")")
    {
      throw std::invalid_argument(
      "syntax error: invalid parentheses expression");
    }
    tokens_.pop_front(); // Consume ')'
    return expr;
  }

  return nullptr;
}

std::unique_ptr<Node::GenericExpr> Parser::recurseTerm()
{
  auto factor = recurseFactor();
  if (!factor)
  {
    return nullptr;
  }

  if (!tokens_.empty() &&
      (tokens_.front().value == "+" || tokens_.front().value == "-"))
  {
    Node::BinaryExpr bin_expr;
    bin_expr.lhs = std::move(factor);
    bin_expr.op = (tokens_.front().value == "+") ?
                  ConstituentToken::ARITHMETHIC_ADD :
                  ConstituentToken::ARITHMETHIC_SUB;
    tokens_.pop_front();
    bin_expr.rhs = recurseExpr();
    auto ptr =
    std::make_unique<std::variant<Node::GenericExpr, Node::BinaryExpr,
                                  Node::UnaryExpr, Node::NumericLiteral>>(
    std::move(bin_expr));
    Node::GenericExpr gen_expr;
    gen_expr.expr = std::move(ptr);
    return std::make_unique<Node::GenericExpr>(std::move(gen_expr));
  }

  return factor;
}

std::unique_ptr<Node::GenericExpr> Parser::recurseExpr()
{
  auto term = recurseTerm();
  if (!term)
  {
    return nullptr;
  }

  if (!tokens_.empty() &&
      (tokens_.front().value == "*" || tokens_.front().value == "/"))
  {
    Node::BinaryExpr bin_expr;
    bin_expr.lhs = std::move(term);
    bin_expr.op = (tokens_.front().value == "*") ?
                  ConstituentToken::ARITHMETHIC_MUL :
                  ConstituentToken::ARITHMETHIC_DIV;
    tokens_.pop_front();
    bin_expr.rhs = recurseExpr();
    auto ptr =
    std::make_unique<std::variant<Node::GenericExpr, Node::BinaryExpr,
                                  Node::UnaryExpr, Node::NumericLiteral>>(
    std::move(bin_expr));
    Node::GenericExpr gen_expr;
    gen_expr.expr = std::move(ptr);
    return std::make_unique<Node::GenericExpr>(std::move(gen_expr));
  }

  return term;
}

std::unique_ptr<Node::GenericExpr> Parser::tokenToExpr()
{
  // lets assume for now the deque only contains valid expression tokens
  // lets assume for now the deque only contains puctuators, literals, operators
  // I guess currently this takes in a deque and pops a token, and processes it
  // as if it is part of an expression
  //
  //
  Token token = tokens_.front();
  if (tokens_.empty())
  {
    throw std::runtime_error("error: empty token deque");
  }
  if (0)
  {
    throw std::invalid_argument("error: non expression token");
  }

  std::unique_ptr<Node::GenericExpr> gen_expr_ptr;
  tokens_.pop_front(); // maybe here maybe at the end

  switch (token.type)
  {
    case GenericToken::IDENTIFIER:
      throw std::runtime_error("identifier : @todo");
    case GenericToken::KEYWORD:
      throw std::invalid_argument("error: keyword found in expression");
    case GenericToken::NUMERIC_LITERAL:
    {
      Node::NumericLiteral node;
      node.token = token;
      node.type = inferTypeNumericLiteral(token.value);
      auto ptr =
      std::make_unique<std::variant<Node::GenericExpr, Node::BinaryExpr,
                                    Node::UnaryExpr, Node::NumericLiteral>>(
      node);
      Node::GenericExpr gen_expr;
      gen_expr.expr = std::move(ptr);
      gen_expr_ptr = std::make_unique<Node::GenericExpr>(std::move(gen_expr));
    }
    break;
    case GenericToken::STRING_LITERAL:
      std::cerr << "recieved: '" << token.value << '\'' << std::endl;
      throw std::runtime_error("string literal : @todo");
    case GenericToken::CHAR_LITERAL:
    {
      Node::NumericLiteral node;
      node.token = token;
      node.type = ConstituentToken::TYPE_CHAR;
      auto ptr =
      std::make_unique<std::variant<Node::GenericExpr, Node::BinaryExpr,
                                    Node::UnaryExpr, Node::NumericLiteral>>(
      node);
      Node::GenericExpr gen_expr;
      gen_expr.expr = std::move(ptr);
      gen_expr_ptr = std::make_unique<Node::GenericExpr>(std::move(gen_expr));
    }
    break;
    case GenericToken::PUNCTUATOR:
      // {
      //   if (dictionary_.find(token.value) == dictionary_.end())
      //   {
      //     std::cerr << "recieved: '" << token.value << '\'' << std::endl;
      //     throw std::invalid_argument("error: dictionary does not contain
      //     punctuator");
      //   }
      //   Node::Punctuator node;
      //   node.token = token;
      //   node.type = dictionary_.at(token.value);
      //   auto ptr =
      //   std::make_unique<std::variant<Node::GenericExpr, Node::BinaryExpr,
      //   Node::UnaryExpr, Node::NumericLiteral>>(node); Node::GenericExpr
      //   gen_expr; gen_expr.expr = std::move(ptr); gen_expr_ptr =
      //   std::make_unique<Node::GenericExpr>(std::move(gen_expr));
      // }
      break;
    case GenericToken::OPERATOR:
      // {
      // if (dictionary_.find(token.value) == dictionary_.end())
      // {
      //   throw std::invalid_argument("error: dictionary does not contain
      //   operator");
      // }
      // Node::Operator node;
      // node.token = token;
      // node.type = dictionary_.at(token.value);
      // auto ptr = std::make_unique<
      // std::variant<Node::GenericExpr, Node::BinaryExpr, Node::UnaryExpr,
      // Node::NumericLiteral, Node::Punctuator>>(node); Node::GenericExpr
      // gen_expr; gen_expr.expr = std::move(ptr); gen_expr_ptr =
      // std::make_unique<Node::GenericExpr>(std::move(gen_expr));
      // }
      break;
    case GenericToken::TYPE:
      throw std::invalid_argument("error: keyword found in expression");
  }
  if (gen_expr_ptr)
  {
    return gen_expr_ptr;
  }
  return std::unique_ptr<Node::GenericExpr>(); // throw exception here
}

/// @todo suppport for optional
/// @todo move some of this to lexer
/// @todo create usuable regex
ConstituentToken Parser::inferTypeNumericLiteral(const std::string &value)
{
  bool is_u_type = value.find('u') != std::string::npos;
  bool is_f_type = value.find('f') != std::string::npos ||
                   value.find('d') != std::string::npos ||
                   value.find('.') != std::string::npos;

  // this is already checked in lexer.cpp
  if (is_u_type && is_f_type)
  {
    throw std::invalid_argument("ambiguous numeric literal");
  }

  // type inference default int
  if (std ::isdigit(value.back()))
  {
    return is_f_type ? ConstituentToken::TYPE_DOUBLE :
                       ConstituentToken::TYPE_INT;
  }

  switch (value.back())
  {
    case 'u': return ConstituentToken::TYPE_UINT;
    case 'i':
      return is_u_type ? ConstituentToken::TYPE_UINT :
                         ConstituentToken::TYPE_INT;
    case 'l':
      return is_u_type ? ConstituentToken::TYPE_ULONG :
                         ConstituentToken::TYPE_LONG;
    case 's':
      return is_u_type ? ConstituentToken::TYPE_USHORT :
                         ConstituentToken::TYPE_SHORT;
    case 'c':
      return is_u_type ? ConstituentToken::TYPE_UCHAR :
                         ConstituentToken::TYPE_CHAR;
    case 'f': return ConstituentToken::TYPE_FLOAT;
    case 'd': return ConstituentToken::TYPE_DOUBLE;
    case '\0':
      return is_u_type ? ConstituentToken::TYPE_UINT :
                         ConstituentToken::TYPE_INT;
    default:
      std::cerr << value << std::endl;
      throw std::invalid_argument("ambiguous numeric literal token");
  }
}

int Parser::numTokens() const { return tokens_.size(); }

void Parser::debugASTPrinter(std::vector<Node::GenericExpr> &vect)
{
  for (const auto &node : vect)
  {
    debugASTPrinterRecursive(node, 0);
  }
}

void Parser::debugASTPrinterRecursive(const Node::GenericExpr &node, int depth)
{
  auto variant = node.expr.get();

  if (!variant)
  {
    std::cout << std::string(depth, '\t') << "variant is null" << std::endl;
    return;
  }

  if (std::holds_alternative<Node::GenericExpr>(*variant))
  {
    std::cout << std::string(depth, '\t') << "recursively holds expression"
              << std::endl;
    debugASTPrinterRecursive(std::get<Node::GenericExpr>(*variant), depth + 1);
  }
  else if (std::holds_alternative<Node::BinaryExpr>(*variant))
  {
    std::cout << "holds binary expression" << std::endl;
    const auto &binaryExpr = std::get<Node::BinaryExpr>(*variant);
    if (binaryExpr.lhs)
    {
      std::cout << std::string(depth, '\t') << "lhs: ";
      debugASTPrinterRecursive(*binaryExpr.lhs, depth + 1);
    }
    if (binaryExpr.rhs)
    {
      std::cout << std::string(depth, '\t') << "rhs: ";
      debugASTPrinterRecursive(*binaryExpr.rhs, depth + 1);
    }
  }
  else if (std::holds_alternative<Node::UnaryExpr>(*variant))
  {
    std::cout << "holds unary expression" << std::endl;
    const auto &unaryExpr = std::get<Node::UnaryExpr>(*variant);
    if (unaryExpr.expr)
    {
      std::cout << std::string(depth, '\t') << "expr: ";
      debugASTPrinterRecursive(*unaryExpr.expr, depth + 1);
    }
  }
  else if (std::holds_alternative<Node::NumericLiteral>(*variant))
  {
    auto literal = std::get<Node::NumericLiteral>(*variant);
    std::cout << "holds numeric literal: " << literal.token.value << std::endl;
  }
  else
  {
    std::cout << "holds ambiguous state" << std::endl;
  }
}
