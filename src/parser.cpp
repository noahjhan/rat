#include "parser.hpp"

/**
 * @brief
 * constructor for parser should validate tokens generated by lexer.
 * Although, lexer should handle most of the errors associated with unrecognized
 * tokens. Realistically, parse errors should occur elsewhere when the provided
 * deque does not match language grammar.
 *
 * skip literals becuase they are
 * validated in lexer in advanceLiteral()
 *
 * skip identifiers because they are
 * validated in lexer in advanceToken()
 *
 * tl;dr
 * this constructor may be redundant / for debug purposes
 */

int add(int a, int b) { return a + b; }

Parser::Parser(std::deque<Token> &tokens) : tokens_(tokens)
{

  for (const auto &token : tokens_)
  {
    if (token.value.empty())
    {
      throw std::invalid_argument("syntax error: empty token");
    }
    switch (token.type)
    {
      case GenericToken::IDENTIFIER: break;
      case GenericToken::KEYWORD:
        if (dictionary_.find(token.value) == dictionary_.end())
        {
          std::cerr << "recieved: '" << token.value << '\'' << std::endl;
          throw std::invalid_argument("syntax error: unrecognized keyword");
        }
        break;
      case GenericToken::NUMERIC_LITERAL: break;
      case GenericToken::STRING_LITERAL: break;
      case GenericToken::CHAR_LITERAL: break;
      case GenericToken::PUNCTUATOR:
        if (dictionary_.find(token.value) == dictionary_.end())
        {
          std::cerr << "recieved: '" << token.value << '\'' << std::endl;
          throw std::invalid_argument("syntax error: unrecognized punctuator");
        }
        break;
      case GenericToken::OPERATOR:
        if (dictionary_.find(token.value) == dictionary_.end())
        {
          std::cerr << "recieved: '" << token.value << '\'' << std::endl;
          throw std::invalid_argument("syntax error: unrecognized operator");
        }
        break;
      case GenericToken::TYPE:
        if (dictionary_.find(token.value) == dictionary_.end())
        {
          std::cerr << "recieved: '" << token.value << '\'' << std::endl;
          throw std::invalid_argument("syntax error: unrecognized type");
        }
        break;
    }
  }
}

/// @todo recursive descent
/// @return
//
std::unique_ptr<Node::GenericExpr> Parser::tokenToExpr()
{
  // lets assume for now the deque only contains valid expression tokens
  // lets assume for now the deque only contains puctuators, literals, operators
  Token token = tokens_.back();
  if (/*invalid token*/ 0)
  {
    throw std::invalid_argument("error: non expression token");
  }

  std::unique_ptr<Node::GenericExpr> gen_expr_ptr;
  tokens_.pop_back(); // maybe here maybe at the end

  switch (token.type)
  {
    case GenericToken::IDENTIFIER: throw std::runtime_error("identifier : @todo");
    case GenericToken::KEYWORD: throw std::invalid_argument("error: keyword found in expression");
    case GenericToken::NUMERIC_LITERAL:
    {
      Node::NumericLiteral node;
      node.token = token;
      node.type = inferTypeNumericLiteral(token.value);
      auto ptr =
      std::make_unique<std::variant<Node::GenericExpr, Node::BinaryExpr, Node::UnaryExpr, Node::NumericLiteral>>(node);
      Node::GenericExpr gen_expr;
      gen_expr.expr = std::move(ptr);
      gen_expr_ptr = std::make_unique<Node::GenericExpr>(std::move(gen_expr));
    }
    break;
    case GenericToken::STRING_LITERAL:
      std::cerr << "recieved: '" << token.value << '\'' << std::endl;
      throw std::runtime_error("string literal : @todo");
    case GenericToken::CHAR_LITERAL: break;
    case GenericToken::PUNCTUATOR: break;
    case GenericToken::OPERATOR: break;
    case GenericToken::TYPE: break;
  }
  if (gen_expr_ptr)
  {
    return gen_expr_ptr;
  }
  return std::unique_ptr<Node::GenericExpr>(); // throw exception here
}

/// @todo suppport for optional
ConstituentToken Parser::inferTypeNumericLiteral(const std::string &value) { return ConstituentToken::TYPE_INT; }

int Parser::numTokens() const { return tokens_.size(); }